# Анализ производительности графических ускорителей NVIDIA GTX 1060 MaxQ и K1

---

**Общая картина тестирования**  
Работа проводилась на NVIDIA GTX 1060 Max‑Q, где тесты проводились на квадратных матрицах типа float. Для матриц с размерами меньше 256 результаты различимы слабо, поэтому они не попали в выборку, а квадратные матрицы размером более 22720 элементов не перемножались из-за ошибок аллокации памяти (максимальный размер, заявленный clinfo – 16384×32768). Особое внимание привлекает пятого и далее ядра, где при work group size = 8 наблюдаются аномальные показатели производительности.

---

**Ключевые причины снижения эффективности продвинутых оптимизаций (начиная с пятого ядра)**

1. **Дополнительные накладные расходы на операции с локальной памятью:**  
   - Пятое и последующие ядра используют оптимизации с предварительной транспозицией и прямоугольными плитками, что требует частых копирований данных в локальную память и синхронизации между потоками.  
   - При квадратных матрицах выгода от улучшения локальности оказывается несущественной, а затраты на дополнительные операции становятся доминирующими.

2. **Ограниченные ресурсы локальной памяти и регистров:**  
   - На GTX 1060 Max‑Q локальная память (shared memory) и регистровый файл достаточно объемны, но продвинутые оптимизации (ядра 6 и 7) требуют ещё большего количества регистров для 2D register blocking и векторных загрузок.  
   - Если объем регистров ограничен, происходит spill‑операция в локальную память, что увеличивает задержки.  
   - Векторное расширение версии 0.7 поддерживается, однако дополнительные инструкции для упаковки данных и управления блоками приводят к дополнительным накладным расходам, не компенсирующим выигрыш от уменьшения обращений к памяти.

3. **Частые барьерные синхронизации:**  
   - Более сложные алгоритмы (ядра 5–10) требуют дополнительных синхронизационных барьеров, что увеличивает задержки, особенно при малом размере рабочей группы (например, 8 потоков), когда каждая задержка имеет критическое значение.

4. **Несоответствие оптимизационных подходов для квадратных матриц:**  
   - Многие продвинутые техники оптимизации разрабатывались для улучшения обработки прямоугольных или несимметричных матриц, где транспозиция может значительно улучшить выравнивание доступа к памяти.  
   - При квадратных матрицах эффект оказывается минимальным, а дополнительные операции лишь добавляют вычислительные затраты.

---

**Сравнение GTX 1060 Max‑Q и PowerVR BXE‑2‑32 (BXE‑32‑2)**

**GTX 1060 Max‑Q:**
- **Локальная память:**  
  Использует быстрый shared memory/L1-кеш объемом примерно 64 КБ с очень низкой латентностью и высокой пропускной способностью. Это позволяет эффективно переиспользовать данные и скрывать задержки доступа к глобальной памяти.
- **Регистровый файл:**  
  Каждый SM содержит обширный регистровый файл (до 65 536 32-битных регистров), что позволяет минимизировать обращения к медленной памяти.
- **Пропускная способность памяти:**  
  Использует GDDR5 с 192-битной шиной и пропускной способностью порядка 192 ГБ/с.
- **Целевая область применения:**  
  Ориентирована на высокопроизводительные вычисления в ноутбуках с балансом между производительностью и энергопотреблением (70–80 Вт).

**PowerVR BXE‑2‑32 (BXE‑32‑2):**
- **Локальная память:**  
  Архитектура построена по принципу tile‑based рендеринга, где каждый тайл обрабатывается в небольшом локальном SRAM. Объём такой памяти существенно меньше, а латентность и пропускная способность уступают решениям типа GTX 1060.
- **Регистровый файл:**  
  Объём регистрового файла значительно ограничен по сравнению с NVIDIA‑GPU; часто используются специализированные регистры для арифметики и адресации, что снижает универсальность и возможности масштабирования.
- **Пропускная способность и интерфейсы:**  
  Работает через системные интерфейсы (например, AXI), где пропускная способность зависит от общей архитектуры системы и, как правило, ниже, чем у выделенной памяти GDDR5.
- **Целевая область применения:**  
  Разработан для ультра‑низкого энергопотребления (около 10 Вт) и малых форм‑факторов, что подходит для устройств IoT и Embedded-систем, но накладывает ограничения на сложные вычислительные задачи.

---

**Сравнение работы продвинутых оптимизаций на двух устройствах:**

- **На GTX 1060 Max‑Q** продвинутые оптимизации (ядра 5–10) могут показывать ухудшение производительности при малых рабочих группах из-за дополнительных операций копирования, синхронизации и недостаточной компенсации улучшенной локальности данных. Ограниченный прирост эффективности register blocking и векторизации приводит к тому, что накладные расходы перевешивают потенциальные выгоды.
  
- **На PowerVR BXE‑2‑32** ситуация усугубляется ещё больше: архитектура tile‑based и малый объём локальной памяти, а также ограниченный регистровый файл делают продвинутые оптимизации особенно неэффективными. Дополнительные операции транспозиции, блокировки и синхронизации приводят к значительным задержкам, которые нельзя компенсировать улучшенной переиспользуемостью данных. Поэтому на таких устройствах более простые алгоритмы (например, наивная реализация или базовый тайлинг) могут работать стабильнее и эффективнее.

---

**Вывод:**  
GTX 1060 Max‑Q и PowerVR BXE‑2‑32 представляют два диаметрально противоположных подхода: первая разработана для высокопроизводительных мобильных устройств с богатой локальной памятью и большими регистровыми файлами, а вторая – для ультра‑низкого энергопотребления и компактных форм‑факторов с ограниченными вычислительными ресурсами. Продвинутые оптимизации (ядра 5–10) оказываются неэффективными на обоих устройствах при работе с квадратными матрицами типа float, особенно при малом размере рабочей группы, однако влияние этих накладных расходов особенно критично для BXE‑2‑32. Здесь дополнительные операции копирования, синхронизации и register blocking не окупаются, что приводит к ухудшению производительности по сравнению с более простыми подходами. Это подчеркивает необходимость адаптировать оптимизации под конкретные аппаратные возможности целевого устройства.

![image](https://github.com/user-attachments/assets/be8dae44-3cc9-436a-935c-8acf105f2bd2)

![image](https://github.com/user-attachments/assets/a7ea6c73-a38b-4577-a2d2-6dfd9d88c565)

![image](https://github.com/user-attachments/assets/6b6157c3-11bf-4f46-b0ea-61c6627d54a6)

![image](https://github.com/user-attachments/assets/b0ebe94b-415e-426c-be50-eb2958b5a425)

![image](https://github.com/user-attachments/assets/0c78b205-f465-4c3b-8c25-324cab1a3c5d)

![Uploading image.png…]()

